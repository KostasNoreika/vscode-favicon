/**
 * Security Tests for Path Validator
 * Tests all attack vectors from CVSS 9.1 vulnerability
 */

const {
    isPathAllowedAsync,
    validatePathAsync,
    sanitizePath,
    getPathCacheStats,
} = require('../../lib/path-validator');
const fs = require('fs');
const path = require('path');
const os = require('os');

describe('Path Validator Security Tests', () => {
    describe('Directory Traversal Attacks', () => {
        test('should block basic directory traversal', async () => {
            expect(await isPathAllowedAsync('/opt/dev/../../etc/passwd')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/../prod/../research/../etc')).toBe(false);
            expect(await isPathAllowedAsync('../../etc/passwd')).toBe(false);
        });

        test('should block relative path segments', async () => {
            expect(await isPathAllowedAsync('/opt/dev/./../../etc')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/../../../root')).toBe(false);
        });

        test('should block paths with .. in directory names', async () => {
            expect(await isPathAllowedAsync('/opt/dev/project..malicious')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/..hidden')).toBe(false);
        });
    });

    describe('URL Encoding Attacks', () => {
        test('should block URL-encoded traversal', async () => {
            expect(await isPathAllowedAsync('%2Fopt%2Fdev%2F..%2F..%2Fetc')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/%2e%2e%2fetc')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev%2f..%2f..%2fetc')).toBe(false);
        });

        test('should block double-encoded traversal', async () => {
            expect(await isPathAllowedAsync('%252Fopt%252Fdev%252F..%252F..%252Fetc')).toBe(false);
            expect(await isPathAllowedAsync('%252e%252e%252f')).toBe(false);
        });

        test('should decode valid URL-encoded paths', () => {
            // Valid paths can be URL encoded
            const result = sanitizePath('%2Fopt%2Fdev%2Fmy-project');
            expect(result).toBe('/opt/dev/my-project');
        });

        test('should handle invalid URL encoding', () => {
            // Malformed URL encoding - triggers catch block in sanitizePath
            const result1 = sanitizePath('/opt/dev/%ZZ');
            expect(result1).toBeNull();

            const result2 = sanitizePath('/opt/dev/%');
            expect(result2).toBeNull();

            const result3 = sanitizePath('/opt/dev/%2');
            expect(result3).toBeNull();
        });
    });

    describe('Null Byte Injection', () => {
        test('should block null byte in path', async () => {
            expect(await isPathAllowedAsync('/opt/dev/project\0malicious')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/project%00malicious')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/project\x00.txt')).toBe(false);
        });

        test('should block URL-encoded null bytes', async () => {
            expect(await isPathAllowedAsync('/opt/dev%00/../etc/passwd')).toBe(false);
        });
    });

    describe('Path Prefix Confusion', () => {
        test('should block paths that start with allowed prefix but escape', async () => {
            expect(await isPathAllowedAsync('/opt/devmalicious')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev-malicious')).toBe(false);
            expect(await isPathAllowedAsync('/opt/prodattack')).toBe(false);
        });

        test('should allow exact allowed paths', async () => {
            expect(await isPathAllowedAsync('/opt/dev')).toBe(true);
            expect(await isPathAllowedAsync('/opt/prod')).toBe(true);
            expect(await isPathAllowedAsync('/opt/research')).toBe(true);
        });

        test('should allow subdirectories of allowed paths', async () => {
            expect(await isPathAllowedAsync('/opt/dev/my-project')).toBe(true);
            expect(await isPathAllowedAsync('/opt/prod/website')).toBe(true);
            expect(await isPathAllowedAsync('/opt/research/experiment-1')).toBe(true);
        });
    });

    describe('Symlink Attacks', () => {
        let tempDir;
        let symlinkPath;

        beforeAll(() => {
            // Create temporary directory for symlink tests
            tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'path-validator-test-'));
            symlinkPath = path.join('/opt/dev', 'malicious-symlink');
        });

        afterAll(() => {
            // Cleanup
            try {
                if (fs.existsSync(symlinkPath)) {
                    fs.unlinkSync(symlinkPath);
                }
                fs.rmSync(tempDir, { recursive: true, force: true });
            } catch (err) {
                // Ignore cleanup errors
            }
        });

        test('should block symlink pointing outside allowed paths', async () => {
            try {
                // Create symlink pointing to /etc (requires permissions)
                if (process.platform !== 'win32' && fs.existsSync('/opt/dev')) {
                    try {
                        fs.symlinkSync('/etc', symlinkPath);
                        expect(await isPathAllowedAsync(symlinkPath)).toBe(false);
                    } catch (err) {
                        // If we can't create symlink (permission denied), skip test
                        console.warn('Skipping symlink test - insufficient permissions');
                    }
                }
            } catch (err) {
                // Skip test if /opt/dev doesn't exist or we lack permissions
                console.warn('Skipping symlink test - directory not accessible');
            }
        });

        test('should resolve symlinks before validation', async () => {
            // Test that symlinks are resolved via fs.promises.realpath
            // Use unique path to avoid cache collisions
            const uniquePath = '/opt/dev/symlink-test-' + Date.now();
            const validation = await validatePathAsync(uniquePath);
            expect(validation.sanitized).toBe(uniquePath.toLowerCase());
        });
    });

    describe('Regex Validation', () => {
        test('should only allow alphanumeric, dash, underscore in directory names', async () => {
            expect(await isPathAllowedAsync('/opt/dev/my-project')).toBe(true);
            expect(await isPathAllowedAsync('/opt/dev/my_project')).toBe(true);
            expect(await isPathAllowedAsync('/opt/dev/project123')).toBe(true);
            expect(await isPathAllowedAsync('/opt/dev/my-awesome-project_v2')).toBe(true);
        });

        test('should block special characters', async () => {
            expect(await isPathAllowedAsync('/opt/dev/project$test')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/project;malicious')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/project|cmd')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/project&test')).toBe(false);
        });

        test('should block paths outside allowed roots', async () => {
            expect(await isPathAllowedAsync('/opt/other')).toBe(false);
            expect(await isPathAllowedAsync('/home/user/project')).toBe(false);
            expect(await isPathAllowedAsync('/tmp/test')).toBe(false);
            expect(await isPathAllowedAsync('/var/www')).toBe(false);
        });
    });

    describe('Edge Cases', () => {
        test('should handle empty or null input', async () => {
            expect(await isPathAllowedAsync('')).toBe(false);
            expect(await isPathAllowedAsync(null)).toBe(false);
            expect(await isPathAllowedAsync(undefined)).toBe(false);
        });

        test('should handle non-string input', async () => {
            expect(await isPathAllowedAsync(123)).toBe(false);
            expect(await isPathAllowedAsync({})).toBe(false);
            expect(await isPathAllowedAsync([])).toBe(false);
        });

        test('should handle very long paths (> 1000 chars)', async () => {
            const longPath = '/opt/dev/' + 'a'.repeat(1000);
            expect(await isPathAllowedAsync(longPath)).toBe(true);

            // Very long path with multiple segments
            const segments = Array(50).fill('abcdefgh').join('/');
            const veryLongPath = '/opt/dev/' + segments;
            expect(await isPathAllowedAsync(veryLongPath)).toBe(true);
        });

        test('should handle paths with dots in allowed names', async () => {
            expect(await isPathAllowedAsync('/opt/dev/project.name')).toBe(true);
            expect(await isPathAllowedAsync('/opt/dev/v2.0.1')).toBe(true);
            expect(await isPathAllowedAsync('/opt/dev/file.backup')).toBe(true);
        });

        test('should handle unicode characters', async () => {
            expect(await isPathAllowedAsync('/opt/dev/проект')).toBe(false); // Cyrillic
            expect(await isPathAllowedAsync('/opt/dev/项目')).toBe(false); // Chinese
            expect(await isPathAllowedAsync('/opt/dev/プロジェクト')).toBe(false); // Japanese
            expect(await isPathAllowedAsync('/opt/dev/café')).toBe(false); // Accented chars
        });

        test('should handle trailing slashes', async () => {
            expect(await isPathAllowedAsync('/opt/dev/')).toBe(true);
            expect(await isPathAllowedAsync('/opt/dev/project/')).toBe(true);
            expect(await isPathAllowedAsync('/opt/dev/project///')).toBe(true);
        });

        test('should handle case sensitivity', async () => {
            // macOS is case-insensitive, paths should be normalized to lowercase
            expect(await isPathAllowedAsync('/Opt/Dev/Project')).toBe(true);
            expect(await isPathAllowedAsync('/OPT/DEV/MY-PROJECT')).toBe(true);
        });
    });

    describe('validatePathAsync() detailed results', () => {
        test('should return detailed validation results for valid paths', async () => {
            // Use unique path to avoid cache collisions from earlier tests
            const uniquePath = '/opt/dev/validation-test-' + Date.now();
            const valid = await validatePathAsync(uniquePath);
            expect(valid.valid).toBe(true);
            expect(valid.sanitized).toBe(uniquePath.toLowerCase());
            expect(valid.resolved).toBeDefined();

            // For invalid paths
            const invalidPath = '/opt/dev-invalid-' + Date.now() + '/../../etc';
            const invalid = await validatePathAsync(invalidPath);
            expect(invalid.valid).toBe(false);
            expect(invalid.error).toBeDefined();
        });

        test('should detect URL encoding issues', async () => {
            const result = await validatePathAsync('%252e%252e');
            expect(result.valid).toBe(false);
            expect(result.error).toContain('encoding');
        });

        test('should detect null byte injection', async () => {
            const result = await validatePathAsync('/opt/dev/test%00');
            expect(result.valid).toBe(false);
            expect(result.error).toContain('Invalid');
        });

        test('should detect path pattern violations', async () => {
            const result = await validatePathAsync('/opt/dev/project$malicious');
            expect(result.valid).toBe(false);
            expect(result.error).toContain('pattern');
        });

        test('should validate paths outside allowed directories', async () => {
            const result = await validatePathAsync('/home/user/project');
            expect(result.valid).toBe(false);
            // Error message varies based on regex vs directory check
            expect(result.error).toBeDefined();
        });
    });

    describe('Real-world Attack Scenarios', () => {
        test('should block AWS metadata service access attempts', async () => {
            expect(await isPathAllowedAsync('/opt/dev/../../../../proc/self/environ')).toBe(false);
        });

        test('should block SSH key access attempts', async () => {
            expect(await isPathAllowedAsync('/opt/dev/../../root/.ssh/id_rsa')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/../../../home/user/.ssh')).toBe(false);
        });

        test('should block /etc/passwd access', async () => {
            expect(await isPathAllowedAsync('/opt/dev/../../etc/passwd')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/../prod/../research/../etc/passwd')).toBe(false);
        });

        test('should block Docker socket access', async () => {
            expect(await isPathAllowedAsync('/opt/dev/../../var/run/docker.sock')).toBe(false);
        });

        test('should block environment variable file access', async () => {
            expect(await isPathAllowedAsync('/opt/dev/.env')).toBe(true); // .env files ARE allowed in project dirs
            expect(await isPathAllowedAsync('/opt/dev/../../root/.env')).toBe(false);
        });
    });
});

describe('Async Validator Tests', () => {
    describe('isPathAllowedAsync', () => {
        test('should validate allowed paths asynchronously', async () => {
            expect(await isPathAllowedAsync('/opt/dev/my-project')).toBe(true);
            expect(await isPathAllowedAsync('/opt/prod/website')).toBe(true);
            expect(await isPathAllowedAsync('/opt/research/experiment')).toBe(true);
        });

        test('should block invalid paths asynchronously', async () => {
            expect(await isPathAllowedAsync('/opt/dev/../../etc/passwd')).toBe(false);
            expect(await isPathAllowedAsync('/opt/devmalicious')).toBe(false);
            expect(await isPathAllowedAsync('/opt/dev/project%00')).toBe(false);
        });
    });

    describe('validatePathAsync', () => {
        test('should return detailed validation results asynchronously', async () => {
            // Use unique paths to avoid cache issues
            const validPath = '/opt/dev/async-valid-' + Date.now();
            const valid = await validatePathAsync(validPath);
            expect(valid.valid).toBe(true);
            expect(valid.sanitized).toBe(validPath.toLowerCase());
            expect(valid.resolved).toBeDefined();

            const invalidPath = '/opt/dev-async-' + Date.now() + '/../../etc';
            const invalid = await validatePathAsync(invalidPath);
            expect(invalid.valid).toBe(false);
            expect(invalid.error).toBeDefined();
        });

        test('should handle various invalid paths', async () => {
            const testCases = [
                { path: '/opt/dev/../../etc/passwd', expectedValid: false },
                { path: '%252e%252e', expectedValid: false },
                { path: '/opt/dev/project%00', expectedValid: false },
                { path: '/opt/dev/async-multi-test-' + Date.now(), expectedValid: true },
            ];

            for (const { path: testPath, expectedValid } of testCases) {
                const result = await validatePathAsync(testPath);
                expect(result.valid).toBe(expectedValid);
            }
        });
    });
});

describe('Integration Tests', () => {
    test('should correctly validate various path scenarios', async () => {
        const testCases = [
            { path: '/opt/dev/my-project', expected: true },
            { path: '/opt/dev/../../etc/passwd', expected: false },
            { path: '/opt/dev%2f..%2f..%2fetc', expected: false },
            { path: '/opt/devmalicious', expected: false },
            { path: '/opt/dev/project%00', expected: false },
        ];

        for (const { path: testPath, expected } of testCases) {
            const result = await isPathAllowedAsync(testPath);
            expect(result).toBe(expected);
        }
    });

    test('should maintain consistent validation behavior', async () => {
        const testPaths = [
            '/opt/dev/my-project',
            '/opt/dev/../../etc/passwd',
            '/opt/dev%2f..%2f..%2fetc',
            '/opt/devmalicious',
            '/opt/dev/project%00',
        ];

        const expectedResults = [true, false, false, false, false];

        for (let i = 0; i < testPaths.length; i++) {
            const result = await isPathAllowedAsync(testPaths[i]);
            expect(result).toBe(expectedResults[i]);
        }
    });
});

describe('Cache Behavior Tests', () => {
    beforeEach(() => {
        // Clear module cache to reset the path validator cache
        jest.resetModules();
    });

    test('should cache validation results and return cached values on second call', async () => {
        const {
            validatePathAsync: validatePathAsync1,
            getPathCacheStats: getPathCacheStats1,
        } = require('../../lib/path-validator');

        const testPath = '/opt/dev/cache-test-' + Date.now();

        // First call - cache miss
        const result1 = await validatePathAsync1(testPath);
        expect(result1.valid).toBe(true);
        expect(result1.sanitized).toBe(testPath.toLowerCase());

        // Second call - should hit cache
        const result2 = await validatePathAsync1(testPath);
        expect(result2.valid).toBe(true);
        expect(result2.sanitized).toBe(testPath.toLowerCase());

        // Verify cache statistics
        const stats = getPathCacheStats1();
        expect(stats.hits).toBeGreaterThan(0);
        expect(stats.size).toBeGreaterThan(0);
    });

    test('should cache negative results (invalid paths)', async () => {
        const {
            validatePathAsync: validatePathAsync2,
            getPathCacheStats: getPathCacheStats2,
        } = require('../../lib/path-validator');

        // Use a unique invalid path pattern to ensure fresh cache entry
        const invalidPath = '/home/invalid-cache-' + Date.now();

        // First call
        const result1 = await validatePathAsync2(invalidPath);
        expect(result1.valid).toBe(false);

        // Second call - should hit cache
        const result2 = await validatePathAsync2(invalidPath);
        expect(result2.valid).toBe(false);

        const stats = getPathCacheStats2();
        expect(stats.hits).toBeGreaterThan(0);
    });

    test('should expire cache entries after TTL', async () => {
        jest.resetModules();

        const {
            validatePathAsync: validatePathAsync3,
        } = require('../../lib/path-validator');

        const testPath = '/opt/dev/ttl-test-' + Date.now();

        // First call
        const result1 = await validatePathAsync3(testPath);
        expect(result1.valid).toBe(true);

        // Mock time advance by 61 seconds (beyond 60s TTL)
        const realDateNow = Date.now;
        Date.now = jest.fn(() => realDateNow() + 61000);

        // This should not use cache (TTL expired)
        const result2 = await validatePathAsync3(testPath);
        expect(result2.valid).toBe(true);

        // Restore Date.now
        Date.now = realDateNow;
    });

    test('getPathCacheStats should return accurate statistics', async () => {
        jest.resetModules();

        const {
            validatePathAsync: validatePathAsync4,
            getPathCacheStats: getPathCacheStats4,
        } = require('../../lib/path-validator');

        // Initial stats
        const stats1 = getPathCacheStats4();
        expect(stats1).toHaveProperty('hits');
        expect(stats1).toHaveProperty('misses');
        expect(stats1).toHaveProperty('size');
        expect(stats1).toHaveProperty('hitRate');

        // Make some calls with unique paths
        await validatePathAsync4('/opt/dev/stats-test1-' + Date.now());
        await validatePathAsync4('/opt/dev/stats-test2-' + Date.now());

        // Cache hit by calling same path twice
        const cachePath = '/opt/dev/stats-test3-' + Date.now();
        await validatePathAsync4(cachePath);
        await validatePathAsync4(cachePath); // This should be a cache hit

        const stats2 = getPathCacheStats4();
        expect(stats2.size).toBeGreaterThan(0);
        expect(stats2.hits).toBeGreaterThan(0);
    });
});

describe('Error Scenario Tests', () => {
    test('should handle EACCES (permission denied) error gracefully', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock fs.promises.realpath to throw EACCES
        fsPromises.realpath = jest.fn().mockRejectedValue({
            code: 'EACCES',
            message: 'Permission denied',
        });

        const { validatePathAsync: validatePathAsync5 } = require('../../lib/path-validator');

        // Path that would normally require realpath resolution
        const result = await validatePathAsync5('/opt/dev/restricted-path');

        // Should fall back to normalized path validation
        expect(result.valid).toBe(true);
        expect(result.sanitized).toBe('/opt/dev/restricted-path');

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });

    test('should handle EIO (I/O error) gracefully', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock fs.promises.realpath to throw EIO
        fsPromises.realpath = jest.fn().mockRejectedValue({
            code: 'EIO',
            message: 'I/O error',
        });

        const { validatePathAsync: validatePathAsync6 } = require('../../lib/path-validator');

        const result = await validatePathAsync6('/opt/dev/io-error-path');

        // Should fall back to normalized path validation
        expect(result.valid).toBe(true);
        expect(result.sanitized).toBe('/opt/dev/io-error-path');

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });

    test('should handle ENOENT (file not found) error', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock fs.promises.realpath to throw ENOENT
        fsPromises.realpath = jest.fn().mockRejectedValue({
            code: 'ENOENT',
            message: 'No such file or directory',
        });

        const { validatePathAsync: validatePathAsync7 } = require('../../lib/path-validator');

        const result = await validatePathAsync7('/opt/dev/nonexistent-path');

        // Should validate based on normalized path
        expect(result.valid).toBe(true);
        expect(result.sanitized).toBe('/opt/dev/nonexistent-path');

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });

    test('should reject paths outside allowed directories even when realpath fails', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock fs.promises.realpath to throw error
        fsPromises.realpath = jest.fn().mockRejectedValue({
            code: 'EACCES',
            message: 'Permission denied',
        });

        const { validatePathAsync: validatePathAsync8 } = require('../../lib/path-validator');

        // Path outside allowed directories - fails regex first
        const result = await validatePathAsync8('/var/malicious-path');

        expect(result.valid).toBe(false);
        // Can be either pattern or allowed directories error depending on validation order
        expect(result.error).toBeDefined();

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });

    test('should handle filesystem errors for symlink resolution', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock fs.promises.realpath to throw ELOOP (too many symlinks)
        fsPromises.realpath = jest.fn().mockRejectedValue({
            code: 'ELOOP',
            message: 'Too many levels of symbolic links',
        });

        const {
            isPathAllowedAsync: isPathAllowedAsync5,
        } = require('../../lib/path-validator');

        // Should still validate based on normalized path
        const result = await isPathAllowedAsync5('/opt/dev/symlink-loop');
        expect(result).toBe(true); // Valid pattern, even if symlink resolution fails

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });
});

describe('Sanitization Edge Cases', () => {
    test('should handle mixed case paths', () => {
        const result = sanitizePath('/Opt/Dev/MyProject');
        expect(result).toBe('/opt/dev/myproject');
    });

    test('should remove multiple trailing slashes', () => {
        const result = sanitizePath('/opt/dev/project///');
        expect(result).toBe('/opt/dev/project');
    });

    test('should handle URL-encoded valid paths', () => {
        const result = sanitizePath('/opt/dev/my%2Dproject');
        expect(result).toBe('/opt/dev/my-project');
    });

    test('should reject malformed URL encoding', () => {
        expect(sanitizePath('/opt/dev/%GG')).toBeNull();
        expect(sanitizePath('/opt/dev/%1')).toBeNull();
    });

    test('should handle empty string after URL decoding', () => {
        const result = sanitizePath('');
        expect(result).toBeNull();
    });
});

describe('Path Validation with Real Filesystem Paths', () => {
    test('should validate when realpath succeeds (existing path)', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock fs.promises.realpath to succeed and return a valid path
        // This tests lines 272-301 (success path when realpath succeeds)
        fsPromises.realpath = jest.fn().mockResolvedValue('/opt/dev/existing-project');

        const {
            validatePathAsync: validatePathAsyncReal,
            isPathAllowedAsync: isPathAllowedAsyncReal,
        } = require('../../lib/path-validator');

        const result = await validatePathAsyncReal('/opt/dev/existing-project');
        expect(result.valid).toBe(true);
        expect(result.sanitized).toBe('/opt/dev/existing-project');
        expect(result.resolved).toBe('/opt/dev/existing-project');

        // Test with isPathAllowedAsync too
        const allowed = await isPathAllowedAsyncReal('/opt/dev/existing-project');
        expect(allowed).toBe(true);

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });

    test('should reject when realpath resolves outside allowed paths (symlink escape)', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock realpath to resolve to a path outside allowed directories
        // This tests the symlink escape detection (lines 282-292 in validatePathAsync)
        fsPromises.realpath = jest.fn().mockResolvedValue('/etc/passwd');

        const {
            validatePathAsync: validatePathAsyncEscape,
            isPathAllowedAsync: isPathAllowedAsyncEscape,
        } = require('../../lib/path-validator');

        const result = await validatePathAsyncEscape('/opt/dev/sneaky-symlink');
        expect(result.valid).toBe(false);
        expect(result.error).toContain('symlink');

        // Test with isPathAllowedAsync
        const allowed = await isPathAllowedAsyncEscape('/opt/dev/sneaky-symlink2');
        expect(allowed).toBe(false);

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });

    test('should handle non-existent paths that are valid patterns', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock realpath to throw ENOENT for non-existent path
        // This tests lines 314-322 and 325-332 (catch block for non-existent paths)
        fsPromises.realpath = jest.fn().mockRejectedValue(new Error('ENOENT'));

        const {
            validatePathAsync: validatePathAsyncNoFile,
        } = require('../../lib/path-validator');

        // Valid pattern but doesn't exist
        const result = await validatePathAsyncNoFile('/opt/dev/future-project');
        expect(result.valid).toBe(true);
        expect(result.sanitized).toBe('/opt/dev/future-project');
        expect(result.resolved).toBeDefined();

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });

    test('should reject non-existent paths outside allowed directories', async () => {
        jest.resetModules();

        const fsPromises = require('fs').promises;
        const originalRealpath = fsPromises.realpath;

        // Mock realpath to throw error
        fsPromises.realpath = jest.fn().mockRejectedValue(new Error('ENOENT'));

        const {
            validatePathAsync: validatePathAsyncOutside,
            isPathAllowedAsync: isPathAllowedAsyncOutside,
        } = require('../../lib/path-validator');

        // Invalid pattern - outside allowed paths
        const result = await validatePathAsyncOutside('/var/www/malicious');
        expect(result.valid).toBe(false);

        // Test with isPathAllowedAsync - tests lines 396-408
        const allowed = await isPathAllowedAsyncOutside('/home/user/attack');
        expect(allowed).toBe(false);

        // Restore original function
        fsPromises.realpath = originalRealpath;
    });
});

describe('Additional getPathCacheStats Tests', () => {
    test('should track cache statistics correctly across multiple operations', async () => {
        jest.resetModules();

        const {
            validatePathAsync,
            isPathAllowedAsync,
            getPathCacheStats,
        } = require('../../lib/path-validator');

        // Get initial stats
        const initialStats = getPathCacheStats();
        expect(initialStats).toHaveProperty('hits');
        expect(initialStats).toHaveProperty('misses');
        expect(initialStats).toHaveProperty('evictions');

        // Perform various operations
        const path1 = '/opt/dev/cache-stat-test1-' + Date.now();
        const path2 = '/opt/dev/cache-stat-test2-' + Date.now();

        await validatePathAsync(path1); // Miss
        await validatePathAsync(path1); // Hit
        await isPathAllowedAsync(path2); // Miss
        await isPathAllowedAsync(path2); // Hit

        const finalStats = getPathCacheStats();
        expect(finalStats.hits).toBeGreaterThan(initialStats.hits);
        expect(finalStats.size).toBeGreaterThan(0);
    });
});
